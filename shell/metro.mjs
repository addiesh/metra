/**
 * Metro JS shell
 * Made with Love (care) and Hate (web development)
 * © addie.sh 2025
 */

// noinspection SpellCheckingInspection
console.log(
	"%c   \n%cMade with Metro",
	// TODO: optimize the project-wide logo instead of creating a subset
	"font-size:128px;background:local url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgNSAzMiAyMiI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJlIj48c3RvcCBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiMwYzE1MjEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiMzNTNjNTgiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iZiI+PHN0b3Agb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojZmZmO3N0b3Atb3BhY2l0eTouNyIvPjxzdG9wIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I2ZmZjtzdG9wLW9wYWNpdHk6MCIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJkIj48c3RvcCBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiMwZWZmMGUiLz48c3RvcCBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiM4MmZmODIiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYyI+PHN0b3Agb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojZmZjYjAwIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojZmZlNTc1Ii8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9ImIiPjxzdG9wIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I2ZmMjYyNiIvPjxzdG9wIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I2ZmNWM1YyIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiM1MjZhY2MiLz48c3RvcCBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNlZGYwZmEiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iZyIgeDE9IjE2LjUiIHgyPSIyMC41IiB5MT0iMjciIHkyPSIzIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaHJlZj0iI2EiLz48bGluZWFyR3JhZGllbnQgaWQ9Im4iIHgxPSI3IiB4Mj0iOC41IiB5MT0iMjQiIHkyPSIxOCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGhyZWY9IiNiIi8+PGxpbmVhckdyYWRpZW50IGlkPSJvIiB4MT0iMTciIHgyPSIxOC41IiB5MT0iMjQiIHkyPSIxOCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGhyZWY9IiNjIi8+PGxpbmVhckdyYWRpZW50IGlkPSJwIiB4MT0iMjUiIHgyPSIyNi41IiB5MT0iMjQiIHkyPSIxOCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGhyZWY9IiNkIi8+PGxpbmVhckdyYWRpZW50IGlkPSJoIiB4MT0iMjQuNSIgeDI9IjEyLjUiIHkxPSIyNSIgeTI9IjciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBocmVmPSIjZSIvPjxsaW5lYXJHcmFkaWVudCBpZD0ibCIgeDE9IjI0LjUiIHgyPSIxMi41IiB5MT0iMjUiIHkyPSI3IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaHJlZj0iI2UiLz48bGluZWFyR3JhZGllbnQgaWQ9ImsiIHgxPSIyNC41IiB4Mj0iMTIuNSIgeTE9IjI1IiB5Mj0iNyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGhyZWY9IiNlIi8+PGxpbmVhckdyYWRpZW50IGlkPSJqIiB4MT0iMjQuNSIgeDI9IjEyLjUiIHkxPSIyNSIgeTI9IjciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBocmVmPSIjZSIvPjxyYWRpYWxHcmFkaWVudCBpZD0iaSIgY3g9IjguNzkxIiBjeT0iNi4wNDgiIHI9IjEzLjY3NCIgZng9IjguNzkxIiBmeT0iNi4wNDgiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEuNzg2IDEuOTI0KXNjYWxlKDEuMTcwMDgpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaHJlZj0iI2YiLz48L2RlZnM+PHBhdGggZD0ibTMgMjQgMy41LTE0TDI1IDZjNS0xLjA4MSA2IDIgNSA2bC0zIDEyaC00bDItOGMxLTQtMy00LTQgMGwtMiA4aC00bDItOGMxLTQtMy00LTQgMGwtMiA4eiIgc3R5bGU9ImZpbGw6dXJsKCNnKTtzdHJva2U6dXJsKCNoKTtzdHJva2Utd2lkdGg6MjtwYWludC1vcmRlcjpzdHJva2UgZmlsbCBtYXJrZXJzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtLjUgMSkiLz48cGF0aCBkPSJtMyAyNCAzLjUtMTRMMjUgNmM1LTEuMDgxIDYgMiA1IDZsLTMgMTJoLTRsMi04YzEtNC0zLTQtNCAwbC0yIDhoLTRsMi04YzEtNC0zLTQtNCAwbC0yIDh6IiBzdHlsZT0iZmlsbDp1cmwoI2kpIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtLjUgMSkiLz48cGF0aCBkPSJtNCAxOCAuNS0xaDlsLS41IDFaIiBzdHlsZT0iZmlsbDp1cmwoI2opIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtLjUgMSkiLz48cGF0aCBkPSJtMTYgMTggLjUtMWg1bC0uNSAxWiIgc3R5bGU9ImZpbGw6dXJsKCNrKSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLS41IDEpIi8+PHBhdGggZD0ibTI0IDE4IC41LTFoNWwtLjUgMVoiIHN0eWxlPSJmaWxsOnVybCgjbCkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0uNSAxKSIvPjxwYXRoIGQ9Im0zIDI0IDEuNS02aDhMMTEgMjRaIiBzdHlsZT0iZmlsbDp1cmwoI24pIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtLjUgMSkiLz48cGF0aCBkPSJNMTUgMjRoNGwxLjUtNmgtNHoiIHN0eWxlPSJmaWxsOnVybCgjbykiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0uNSAxKSIvPjxwYXRoIGQ9Ik0yNC41IDE4aDRMMjcgMjRoLTR6IiBzdHlsZT0iZmlsbDp1cmwoI3ApIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtLjUgMSkiLz48L3N2Zz4=') left/contain no-repeat;",
	"color:light-dark(#000,#fff);font-size:32px;font-family:Inter Display,Inter,system-ui;",
);
console.log(
	"%c© addie.sh",
	"color:light-dark(#000,#fff);font-size:16px;font-family:Inter Display,Inter,system-ui;"
)

/** @type {HTMLCanvasElement} */
const canvas = document.getElementById('metro');
/** @type {WebGL2RenderingContext} */
const gl = canvas.getContext('webgl2');

/**
 * @typedef {object} MetroExports
 * @prop {object} exports
 * @prop {WebAssembly.Memory} exports.memory
 * @prop {WebAssembly.Global} exports.metroVarBigEndian
 * @prop {() => 0|1} exports.metroUpdate
 * @prop {() => void} exports.metroMain
 * @prop {() => void} exports.metroClean
 * 
*/
/**
 * @typedef {WebAssembly.Instance & MetroExports} Metro
*/
const context = {
	/** @type {Metro} */
	metro: undefined,

	// TODO: this is slow, replace with something faster.
	/** @type {Map<number, WebGLBuffer|WebGLProgram|WebGLShader|WebGLFramebuffer|WebGLRenderbuffer|WebGLTexture|WebGLVertexArrayObject>} */
	objects: new Map(),
};

/**
 * this is a horrible """algorithm""" and totally sucks.
 * but I'm tired, and we have a massive performance budget
 * @returns {number}
 */
function findKey() {
	let key = context.objects.size + 1;
	while (true) {
		if (context.objects.get(key) === undefined) {
			return key;
		} else {
			key = (key + 1) % 0xFFFFFFFF;
		}
	}
}

/** @type {?Uint8Array} */
let cachedSaveBuffer = null;
/** @type {?string} */
let cachedSaveString = null;
let textDecoder = new TextDecoder();
let textEncoder = new TextEncoder();

// noinspection JSUnusedGlobalSymbols
const importObject = {
	metroSys: {
		/**
		 * @param {1|2|3|4|5|6} level 
		 * @param {number} _targetPtr 
		 * @param {number} _targetLen 
		 * @param {number} locationPtr
		 * @param {number} locationLen
		 * @param {number} contentPtr 
		 * @param {number} contentLen 
		 */
		log: function (
			level,
			_targetPtr,
			_targetLen,
			locationPtr,
			locationLen,
			contentPtr,
			contentLen,
		) {
			let levelFnMap = ['error', 'warn', 'info', 'debug', 'trace', 'error'];
			let levelStringMap = ['ERROR', 'WARNING', 'INFO', 'DEBUG', 'TRACE', 'PANIC!'];
			// currently unused
			// let target = ((targetPtr && targetLen) ? textDecoder.decode(
			// 	context.metro.exports.memory.buffer.slice(targetPtr, targetPtr + targetLen),
			// ) : "");
			let location = ((locationPtr && locationLen) ? textDecoder.decode(
				context.metro.exports.memory.buffer.slice(locationPtr, locationPtr + locationLen),
			) : "");
			let content = ((contentPtr && contentLen) ? textDecoder.decode(
				context.metro.exports.memory.buffer.slice(contentPtr, contentPtr + contentLen),
			).replaceAll('%', '%%') : "");
			let string = `%c[${levelStringMap[level - 1]} ${location}]%c ${content}`;
			console[levelFnMap[level - 1]](
				string,
				"font-weight:800;",
				""
			);
		},

		/**
		 * @return {number} The time (in milliseconds) since program start.
		 */
		getTime: function () {
			// TODO: stub...?
			return performance.now();
		},

		/**
		 * @return {number}
		 */
		getRandom: function () {
			return Math.random();
		},

		/**
		 * @param {number} dataPtr The pointer to write to
		 * @param {number} dataLen
		 * @return {number} 0 on success, length required if the buffer is null/too small, u32::MAX on unknown error
		 */
		loadPersistent: function (
			dataPtr,
			// TODO: technically dataLen probably isn't necessary,
			//		 but we don't have safeguards in place if the data changes mid-transfer.
			dataLen,
		) {
			if (cachedSaveBuffer === null) {
				try {
					cachedSaveString = localStorage.getItem('metroPersistent');
					if (cachedSaveString == null) {
						cachedSaveBuffer = new Uint8Array(0);
					} else {
						cachedSaveBuffer = textEncoder.encode(cachedSaveString);
					}
				} catch (err) {
					console.error("Error reading from persistent data:", err);
					return 0xFFFFFFFF;
				}
			}

			if (dataPtr === 0 || dataLen === 0) {
				return cachedSaveBuffer.byteLength;
			} else {
				// this branch should never be called if len == 0, as enforced by caller
				let view = new Uint8Array(context.metro.exports.memory.buffer, dataPtr, dataLen);
				view.set(cachedSaveBuffer, 0);
				return 0;
			}
		},

		/**
		 * @param {*} dataPtr 
		 * @param {*} dataLen 
		 * @returns {0|1} 1 on success or 0 otherwise.
		 */
		savePersistent: function (
			dataPtr,
			dataLen,
		) {
			try {
				let buf = context.metro.exports.memory.buffer.slice(dataPtr, dataPtr + dataLen);
				cachedSaveString = textDecoder.decode(buf);
				localStorage.setItem('metroPersistent', cachedSaveString);
				cachedSaveBuffer = new Uint8Array(buf);
				return 1;
			} catch (err) {
				console.error("Error writing to persistent data:", err);
				return 0;
			}
		},

		createVertexArray: function () {
			gl.createVertexArray();
			// TODO:
			return 0xACAB;
		},

		createShader: function (
			shaderStage,
			sourcePtr,
			sourceLen,
		) {
			let shader = gl.createShader(
				[gl.VERTEX_SHADER, gl.FRAGMENT_SHADER][shaderStage]
			);
			gl.shaderSource(
				shader,
				textDecoder.decode(context.metro.exports.memory.buffer.slice(sourcePtr, sourcePtr + sourceLen)),
			);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				console.error(`Failed to compile ${["vertex", "fragment"][shaderStage]} shader!`, gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);
				return 0;
			}

			let key = findKey();

			console.debug(`created shader with ID ${key}`);

			context.objects.set(key, shader);
			return key;
		},

		dropShader: function (shader) {
			let obj = context.objects.get(shader);
			if (obj === undefined) {
				return 0;
			} else {
				gl.deleteBuffer(context.objects[shader]);
				context.objects.delete(shader);
				console.debug(`dropped shader with ID ${shader}`);
				return 1;
			}
		},

		createProgram: function (
			vertex,
			fragment,
		) {
			let program = gl.createProgram();
			gl.attachShader(program, context.objects.get(vertex));
			gl.attachShader(program, context.objects.get(fragment));
			gl.linkProgram(program);

			if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				console.error("Failed to link shader program!", gl.getProgramInfoLog(program));
				gl.deleteProgram(program);
				return 0;
			}

			let key = findKey();

			console.debug(`created program with ID ${key}`);

			context.objects.set(key, program);

			return key;
		},

		dropProgram: function (program) {
			let obj = context.objects.get(program);
			if (obj === undefined) {
				return 0;
			} else {
				gl.deleteBuffer(context.objects[program]);
				context.objects.delete(program);
				console.debug(`dropped program with ID ${program}`);
				return 1;
			}
		},

		createBuffer: function (
			bufferType,
			dataPtr,
			dataLen,
		) {
			let buffer = gl.createBuffer();
			// This is enum conversion.
			let target = [gl.ARRAY_BUFFER, gl.ELEMENT_ARRAY_BUFFER, gl.UNIFORM_BUFFER][bufferType];
			// I've designed the API in such a way that makes it impossible to really re-use buffers
			// as the game developer, so pretty much every buffer will be STATIC_DRAW.
			let usage = gl.STATIC_DRAW;
			gl.bindBuffer(
				target,
				buffer,
			);
			gl.bufferData(
				target,
				context.metro.exports.memory.buffer.slice(dataPtr, dataPtr + dataLen),
				usage
			);
			
			let key = findKey();

			console.debug(`created buffer with ID ${key}`);

			context.objects.set(key, buffer);
			return key;
		},

		dropBuffer: function (buffer) {
			let obj = context.objects.get(buffer);
			if (obj === undefined) {
				return 0;
			} else {
				gl.deleteBuffer(context.objects[buffer]);
				// context.freeBuffers.push()
				context.objects.delete(buffer);
				console.debug(`dropped buffer with ID ${buffer}`);
				return 1;
			}
		}
		
	}
};

{
	console.info("Loading Metro WASM...");
	let bt = performance.now();
	// noinspection JSValidateTypes
	context.metro = (await WebAssembly.instantiateStreaming(
		fetch("metro-game.wasm"),
		importObject
	)).instance;
	let pt = performance.now();
	console.info(`Done loading! (complete in ${pt - bt}ms)`);
}

{
	// https://bsky.app/profile/addie.sh/post/3lqq6ixhjp22q
	let u16 = new Uint16Array([0xACAB]);
	let u8 = new Uint8Array(u16.buffer);
	let addr = context.metro.exports.metroVarBigEndian.value;
	let view = new DataView(context.metro.exports.memory.buffer, addr, 4);

	switch (u8[0]) {
		case 0xAC: {
			console.info("running on big-endian system, enabling transpose flag");
			view.setUint32(0, 1, true);
			throw Error("...is what it would say, if it actually did anything. TODO: implement");
			// break;
		}
		case 0xAB: {
			console.info("running on little-endian system, no corrections required");
			view.setUint32(0, 0, true);
			break;
		}
		default: {
			// :(
			throw Error(`Eldritch endianness (0x${u8[0].toString(16)}${u8[1].toString(16)})`);
		}
	}
}

let eventQueue = [];

{
	/** @type {Gamepad[]} */
	let gamepads = [];
	/** @type {Map<string, boolean>} */
	let keyState = new Map();

	canvas.addEventListener('keydown', e => {
		// e.key
	});
	canvas.addEventListener('keyup', e => {

	});

	window.addEventListener("gamepadconnected", e => {
		gamepads.push(e.gamepad);
		console.log(`Gamepad connected at index ${e.gamepad.index}: ${e.gamepad.id}. ${e.gamepad.buttons.length} buttons, ${e.gamepad.axes.length} axes.`);
		console.log(gamepads);
	});

	window.addEventListener("gamepaddisconnected", e => {
		console.log(`Gamepad disconnected at index ${e.gamepad.index}: ${e.gamepad.id}.`);
		gamepads = gamepads.filter(v => v.index === e.gamepad.index);
		console.log(gamepads);
	});
}

let isRunning = true;

// initialize stuff
context.metro.exports.metroMain();

function main() {

	// gl.viewport
	let res = context.metro.exports.metroUpdate();
	if (res === 0) {
		isRunning = false;
	}

	gl.viewport(0, 0, canvas.width, canvas.height);
	gl.clearColor(0, 0, 0, 0);
	gl.clear(gl.COLOR_BUFFER_BIT /* | gl.DEPTH_BUFFER_BIT */);
	// gl.enable(gl.DEPTH_TEST);
	// gl.enable(gl.CULL_FACE);

	gl.flush();

	if (isRunning) {
		requestAnimationFrame(main);
	} else {
		context.metro.exports.metroClean();
	}
}

function resize() {
	let bounds = canvas.getBoundingClientRect();
	canvas.width = bounds.width * window.devicePixelRatio;
	canvas.height = bounds.height * window.devicePixelRatio;
}
window.addEventListener('resize', resize);
resize();

main();